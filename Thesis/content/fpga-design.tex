\chapter{FPGA tervezés}
\label{sec:fpga-desing-begining}

A Nintendo Entertainment System hardveres komponenseinek újratervezése során az ISE Design Suite szoftvert és a Verilog hardverleíró nyelvet választottam. A tervezés fő szempontja az áttekinthetőség, %% beláthatóság?
céltudatosság és tesztelhetőség volt, mely tulajdonságok elengedhetetlenek egy nagyobb projekt fejlesztése során. A megtervezett chipeknek az összehangolt és hibátlan (az eredeti NES hardverrel megegyező) működésének ellenőrzését követően léptem tovább a következő fejlesztési egységre.

A következőkben a diplomamunka során tervezett és tesztelt hardveres komponensek működését és felépítést fogom bemutatni, az úgynevezett "top-down" elv alapján. Ennek jelentése, hogy először a teljes rendszer kapcsolatát mutatom be, majd ezt követően térek ki a különböző elemek részletes működésére.

\begin{figure}[H]
	\centering
	\includegraphics[width=150mm, keepaspectratio]{figures/FPGA-toplevel-diagram}
	\caption{Megvalósult FPGA projekt (nes\_top) diagramja} 
	\label{fig:FPGA-toplevel-diagram}
\end{figure}
%\section{Rendszer blokkvázlat bemutatása}

% ebben valami nem kóser a zárójel környékén
Az FPGA tervezés első fázisában a NES eredeti hardverét a különböző funkciókat ellátó hardveres elemek (chipek) alapján modulokra osztottam. Ezeket a modulokat és a köztük lévő logikai kapcsolatokat láthatjuk \aref{fig:FPGA-toplevel-diagram}. ábrán.

% két FAJTA/CSOPORT adatkapcsolat van ha jól értem, nem két adatkapcsolat
A modulok között kétfajta logikai adatkapcsolat látható, az első a kommunikációs buszok (vastag nyilak), ezek többféle vezetéket foglalnak magukba (adat, cím, vezérlőjelek), ezek pontos tartalmát a nyilak kezdőpontjánál láthatjuk. A második pedig a rendszer órajelek. Ide tartoznak a rendszerórajelből előállított, $\phi_1$ és $\phi_2$ szinkronizációs jelek is.
% phit megcsinálni

\section{A buszok implementálása}

A NES eredeti belső logikai kapcsolatait alapul véve, két fő adatbuszt különböztetünk meg, a CPU és a PPU adatbuszt. 

A PPU adatbusz struktúrájában egyszerűbb, csupán a memória %memória kezelő?
kezelő modullal kommunikál. Az itt található névtábla (NT) memóriát írja és olvassa, illetve a karakter ROM tartalmát olvassa. %ezt nem értem, de lehet értelmes

A CPU adatbusz működése a DMA miatt egy fokkal bonyolultabb. Alapesetben a CPU az adatbuszán keresztül éri el a címtartományában található különböző perifériák regisztereit/memóriáit. A slave interfészek implementálása során ügyeltem arra, hogy a különböző hardveres komponensek minél egyszerűbben fogadják a CPU adatbuszát (ezzel egyszerűsítve a szintetizálandó hardveren). Ez \aref{code:cpu-databus-simplification}. hardverleírásban is látható. Viszont a DMA a működése során elveheti a processzor adatbuszát% ki veheti át? és nem írányítást vesz át?
, ilyenkor ő végez memória és regiszter hozzáféréseket a perifériákon. A helyes cím kiadása mellett a DMA elveszi a processzor Ready jelét is, ezzel blokkolva CPU működését és megakadályozva a busz több master egység általi meghajtását. A különböző modulok kimeneti jelei úgy lettek megtervezve, hogy csak megfelelő időzítés mellett adjanak ki adatokat (különben nullát), így \aref{code:cpu-data-bus}. hardverleírásban is látható, hogy a különböző kimenetek egyszerű logikai vagy kapcsolatával tudjuk a perifériák olvasási adatbuszait összekötni.

\begin{lstlisting}[caption={CPU adatbuszt befolyásoló DMA jelek}, label={code:cpu-data-bus}, style=prettyverilog]
// CPU data in
wire [7:0] cpu_din = (memory_manager_cpu_din | ppu_to_cpu_din | controller_cpu_din);

// DMA and CPU outputs
assign cpu_addr = (dma_cpu_avalid) ? (dma_cpu_addr) : (nes6502_addr);
assign cpu_dout = (dma_cpu_dout | nes6502_dout);
assign rnw = ~(~dma_cpu_rnw | ~nes6502_rnw);\end{lstlisting}

A különböző interfészek egyszerűsítése során \aref{tab:CPU-Memory}. táblázatban és \aref{sec:NT-AT-mirroring}. fejezetben bemutatott tükrözés (\textit{mirroring}) módszerét % ez nem egy módszer?
használtam ki. Ennek alapja hogy csupán a címbusz adott bitjeit figyeljük, például PPU regiszterek esetén az alsó három bitet. Ezzel párhuzamosan pedig megpróbálunk egy megfelelő kiválasztó jelet generálni a chiphez, PPU esetén a felső három bit fixálja a \$2000 - \$3FFF-ig tartó cím tartományt. Ilyen egyszerűsítést alkalmaztam a kontrollerek és DMA interfész esetén is (lásd \ref{code:cpu-databus-simplification}. hardverleírás).

\begin{lstlisting}[caption={A CPU adatbusz interfészek egyzserüsítése}, label={code:cpu-databus-simplification}, style=prettyverilog]
// PPU Slave interface bemenet
.slv_mem_addr(cpu_addr[2:0]),      				// register interface reg select (#2000-#2007)
.slv_mem_cs((cpu_addr[15:13] == 3'b001)), 		// register interface enable (#2000 - #3FFF just when it is active)

// Controller inputs
.cpu_data_in(cpu_dout[0]), //just one bit the $4016 write strobe

// DMA Slave databus
.slv_mem_select((ag6502_addr[15:14] == 2'b01)),  
.slv_mem_addr(ag6502_addr[4:0]),\end{lstlisting}

\section{Működési órajel választása}

Egyik első feladat FPGA tervezés során a hardver átgondolását követően, a rendszerórajel kiválasztása. Erről a fő órajelről fogjuk működtetni a szinkron tárolóinkat, a memória elérésünket és az összes perifériánk időzítésének is ez lesz az alapja. A NES megvalósítása során használtam két specifikusabb órajelet is a rendszer órajel mellett, ezeket a TMDS jelek előállítása során használtam fel. Ezek a kiemelt órajelek a többi FPGA-n található jeltől elkülönített helyen, a globális órajel hálózatban terjednek. Ennek is van késleltetése, amelyet az időzítés analízis figyelembe vesz és ez alapján befolyásolja az elérhető legmagasabb órajel frekvenciát. Ehhez az órajel hálózathoz csatlakozik a külső oszcillátorunk, % nem ehhez a hálózathoz?
 illetve a PLL és DCM FPGA-n belüli hardveres elemek is, amelyek lehetővé teszik az órajelek frekvenciájának változtatását.

%itt kicsit zavaros, hgoy melyik jelből mennyi van, egyes-többes számot kell lecsekkolni
A NES kártyán egy 50 MHz-es külső órajel forrást helyeztem el. \Aref{sec:picture-creation-ideas}. fejezetben leírtak alapján a rendszer órajelemet a megjelenítésnek megfelelően kell megválasztanom, ezt figyelembe véve a működési (rendszer) órajelemet 25 MHz-nek választom. A beérkező 50 MHz-ből a PLL helyes beállítása során előállítok 25 MHz-et és 250 MHz-et. A VGA kép generálásához szükségem lesz mind a három órajelre, a 25 MHz a pixel órajelem lesz (erre a jelre kell előállítanom a  24 bites RGB értékeimet), az 50 MHz az 5 bites párhuzamos-soros átalakítókhoz kell, végül pedig 250 MHz-el fogom kiadni a biteket a HDMI differenciális adatvezetékei számára. 

%phit itt is megcsinálni
\begin{lstlisting}[caption={6502 $\phi_1$ és $\phi_2$ vezérlőjelek előállítása}, label={code:6502-clocksignals}, style=prettyverilog]
reg  clkgen_cnt_en_clr;
wire clkgen_cnt_en_set = (x_rendercntr == (ODDFRAME_END_OF_BG_RENDERING_LINE + 4));
always @(*) 
begin
	if (background_enabled && oddframe && (y_renderingcntr == PRERENDERING_ROW))
		clkgen_cnt_en_clr <= (x_rendercntr == ODDFRAME_END_OF_BG_RENDERING_LINE);
	else
		clkgen_cnt_en_clr <= 1'b0;	
end

// clock genereation enable
reg		clkgen_cnt_en;
always @ (posedge clk)
begin
	if (rst || (x_rendercntr == END_OF_BG_RENDERING_LINE) || clkgen_cnt_en_clr)
		clkgen_cnt_en <= 1'b0;
	else
		if ((x_rendercntr == FIRST_SCANLINE_PIXEL) || clkgen_cnt_en_set)
			clkgen_cnt_en <= 1'b1;
end	

//clock generation timer
reg	[3:0]	clkgen_cnt;
always @ (posedge clk)
begin
	if (rst)
		clkgen_cnt <= 4'd0;
	else
		if (clkgen_cnt_en)
			if (clkgen_cnt == 4'd11)
				clkgen_cnt <= 4'd0;
			else
				clkgen_cnt <= clkgen_cnt + 4'd1;
end

always @ (posedge clk)
begin
	ph1_rising	<= clkgen_cnt_en & (clkgen_cnt == 4'd0);
	ph1_falling <= clkgen_cnt_en & (clkgen_cnt == 4'd5);
	ph2_rising	<= clkgen_cnt_en & (clkgen_cnt == 4'd6);
	ph2_falling <= clkgen_cnt_en & (clkgen_cnt == 4'd11);
end\end{lstlisting}

%phi
Ezekből az órajelekből kell előállítani a NES hardver számára a megfelelő kiválasztó jeleket. Az NTSC NES-ben található MOS 6502 1,789773 MHz-es bemeneti $\phi_0$ órajellel rendelkezik. Ebből hozza létre a eltolt fázisú $\phi_1$ és $\phi_2$ külső időzítési órajelet. %fázis tolt?
A $\phi_2$ órajel lefutó élére történik a periféria adatok olvasása. 

%phi
A rendszer %projekt helyett rendszer vagy kártya vagy eszköz
VGA rendrelését úgy implementáltam, hogy amíg a PPU képgenerálást kiegészíti a hardver VGA jellé, addig a PPU és vele együtt az egész NES hardver egy alvó állapotban várakozik. Ezt a $\phi_1$ és $\phi_2$ jelek megfelelő időben történő generálásával (késleltetésével) tudtam kialakítani. Ezt láthatjuk \aref{code:6502-clocksignals}. hardverleírásban. A Verilog kód első felében azt láthatjuk, hogy a PPU aktív kép generálása során az óra jel generálásáért felelős számláló engedélyezve van, viszont a képalkotás végeztével (VGA blanking terület) a számlálót tiltjuk. Legfelül pedig az látható, hogy az eredeti PPU megkülönböztette minden második (páratlan) kép generálását úgy, hogy specifikus pixeleket kihagyott a generálásból, ezt is figyelembe kell venni a hardver tervezése során (clkgen\_cnt\_en\_clr jel). Ezt követően pedig kiszámolható, hogy a 25 MHz-es órajelünkre működtetett számlálót, ha 11-re nullába állítjuk, akkor az első hat óra el alatt aktív a $\phi_1$ és a második hat alatt pedig a $\phi_2$. Ha ehhez még hozzászámoljuk a számláló megfelelő engedélyezését, ~1,8 MHz körüli értéket kapunk. Ezen órajelek felfutó és a lefutó éleihez tartozó számláló élállapotok kerülnek dekódolásra a Verilog kód második felében (\ref{fig:FPGA-phi1-phi2}. ábra).

\begin{figure}[H]
	\centering
	\includegraphics[width=150mm, keepaspectratio]{figures/fpga-ph1-ph2}
	\caption{MOS 6502 órajel generálása (FPGA sim)} 
	\label{fig:FPGA-phi1-phi2}
\end{figure} 

\section{Picture Process Unit}
\label{sec:PPU-FPGA}

A PPU időzítésének és működésének alappillérét két számláló, egy horizontális és egy vertikális számláló képzi. Ezek szinkronban végigkövetik a teljes eredeti képgenerálást és ezzel együtt a új HDMI-n keresztül történő képgenerálást is. \Aref{sec:picture-creation-ideas}. fejezetben bemutatott két módszer közül az egyszerűbb megoldást választottam a képgenerálás megalkotására. Tehát minden egyes NES pixelt felnagyítok 2x2-es pixelekké, ezzel egy pixelesebb %pixelesebb de élesebb? ezek egymás ellentétei
képet kapva végeredményként (amely jobban hasonlít az eredeti konzol képére).

%itt mintha a pixel és az órajel kompatibilis lenne egymással. Nem pixel előállítása(ának ideje) és órajel, amik kompatibilisek?
Az NTSC PPU képalkotásának leírását %képalkotásáabnk leírását, nem?
\aref{sec:NTSC-PPU-frame}. függelékben láthatjuk. Az eredeti hardver, a 0-239-ig tartó sorokban, az 1. pixeltől kedve a 256. pixelig minden egyes órajelben előállít egy pixelt (kompozit jelként)% ezt nem értem
. Ha ezt a képalkotást szeretnénk szinkronba hozni a 640x480 pixeles VGA jel előállításával, ami 800 pixelt jelent horizontálisan és 525 sort vertikálisan a kioltási tartományokat is beleértve, akkor egy 1600-as horizontális és egy 261-ig tartó vertikális számlálóra van szükség, ezáltal egy PPU sor ideje alatt, két sor VGA képet küldünk ki. Természetesen így egy puffereléssel el kell csúsztatnunk a VGA képalkotást a PPU-hoz képest és az 1600-as PPU sort minden második rendszerórajelre kell mintavételeznünk. Ennek függvényében \aref{sec:NTSC-PPU-frame}. függelékben látható állapotgépek állapotaiban töltött időt is meg kell hosszabbítani, még hozzá úgy, hogy a képen látható horizontális pixel órajel minden órajele az FPGA képalkotásban négy rendszer órajelnek feleljen meg. 

	\subsection{CPU által elérhető regiszterek és CPU adatbusz}
	\label{sec:CPU-databus-ppu_reg}

    %phi
	Először is tekintsük meg a CPU adatbusz címének dekódolását és az ebből előállított vezérlőjeleket a PPU számára (\ref{code:CPU-signals-decode}. hardverlírás részlet). Ezek a jelek vezérlik a chip belső hét regiszterének elérését. A regiszterek írását a $phi_2\_falling$ jelre szinkronizálom (inaktív RNW jel mellett). Az olvasás során pedig az adatokat a $phi_2\_rising$ jel hatására (aktív RNW jel mellett) helyezem el a CPU buszinterfész adatkimenetén. Ezt az adat kimenetet a $phi_2\_falling$ jelre nullába állítom, az adatbusz helyes működése érdekében.
	
\begin{lstlisting}[caption={A CPU adatbusz feldolgozása (PPU vezérlőjelek)}, label={code:CPU-signals-decode}, style=prettyverilog]
//CTRL register write #2000
wire control_wr     = ph2_falling & slv_mem_cs & ~slv_mem_rnw & (slv_mem_addr == 3'b000);
//MASK register write #2001 
wire render_mask_wr = ph2_falling & slv_mem_cs & ~slv_mem_rnw & (slv_mem_addr == 3'b001);
//OAM read/write address #2003 
wire oam_addr_wr    = ph2_falling & slv_mem_cs & ~slv_mem_rnw & (slv_mem_addr == 3'b011);
//OAM data read/write #2004 
wire oam_data_wr    = ph2_falling & slv_mem_cs & ~slv_mem_rnw & (slv_mem_addr == 3'b100);
//fine scroll position (two writes: X scroll, Y scroll) #2005
wire scrolling_wr   = ph2_falling & slv_mem_cs & ~slv_mem_rnw & (slv_mem_addr == 3'b101);
//PPU read/write address (two writes: most significant byte, least significant byte) #2006
wire vram_addr_wr   = ph2_falling & slv_mem_cs & ~slv_mem_rnw & (slv_mem_addr == 3'b110);
//PPU data read/write #2007 
wire vram_data_wr   = ph2_falling & slv_mem_cs & ~slv_mem_rnw & (slv_mem_addr == 3'b111);
//Register read enable signals
wire status_rd      = slv_mem_cs & slv_mem_rnw & (slv_mem_addr == 3'b010);
wire oam_data_rd    = slv_mem_cs & slv_mem_rnw & (slv_mem_addr == 3'b100);
wire vram_data_rd   = slv_mem_cs & slv_mem_rnw & (slv_mem_addr == 3'b111);\end{lstlisting}

	A CPU által írt PPU regiszterek értékét \aref{code:CPU-signals-decode}. részletben látható vezérlőjelek segítségével mentem regiszterekbe. Majd ezeknek a regisztereknek a megfelelő bitjeit szétbontom a könnyebb feldolgozás érdekében. Viszont a PPU rendelkezik 16 bites belső regiszterekkel is, ezeket a regisztereket kétszeri írással tudja elérni a CPU 8 bites adatbusza. Ilyen regiszter a görgetési pozíció és a VRAM cím regisztere. Az FPGA projektben \aref{code:second-write}. hardverleírásban látható $second\_write$ jel segítségével vagyunk képesek a regiszterek második írásának detektálására. A második 8 bites adat mentésé pedig ennek a jelnek és a regiszter írását jelző jel hatására történik.

\begin{lstlisting}[caption={Cím és görgetés regiszterek második írásának figyelése}, label={code:second-write}, style=prettyverilog]
reg second_write;
always @ (posedge clk) 
begin
	if (rst || (status_rd && ph2_falling))
		second_write <= 1'b0;
	else
		if (scrolling_wr || vram_addr_wr)
			second_write <= ~second_write;
end\end{lstlisting}
	
	A PPU regiszter elérésének vannak olyan részei, amelyek időzítés kritikusak (ha ezekre nem figyelünk a játékaink képgenerálásában különböző hibákat figyelhetünk meg). Ilyen például a VRAM írása és olvasása, ezeket a jeleket megfelelő módon késleltetnünk kell, hogy szinkronban legyenek a PPU megjelenítéshez tartozó memória eléréseivel. Erre a legkönnyebb mód egy állapotgép, ezt \aref{fig:VRAM-read-write-FSM}. ábrán láthatjuk.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=115mm, keepaspectratio]{figures/VRAM-read-write-FSM}
		\caption{CPU-ból ékrekző VRAM írási és olvasási jelek PPU időzítéséhez igazító állapotgép} 
		\label{fig:VRAM-read-write-FSM}
	\end{figure} 	
	
	\subsection{Háttér képalkotást és memória olvasást vezérlő állapotgép}
	
	\Aref{PPU-irodalom}. fejezetben olvasottak alapján az eredeti PPU kép generálását két nagyobb egységre bonthatjuk: a háttér, és a mozgó csempe elemek (sprite-ok) %itt szerintem valami kihagyható, vayg zárójelezni kell
 generálására. Ebben a fejezetben először az FPGA-ban implementált háttér generálási megoldást olvashatjuk.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=150mm, keepaspectratio]{figures/bg-rendering-FSM}
		\caption{Háttér képalkotás és memória olvasást vezérlő állapotgép} 
		\label{fig:bg-rendering-FSM}
	\end{figure} 
	
	Az FPGA projekt háttér képalkotását, \aref{fig:bg-rendering-FSM}. ábrán látható állapotgép határozza meg. Az állapot átmenetek képzéséhez a chip horizontális és vertikális számlálóit használtam, illetve az eredeti háttér alkotási leírást vettem alapul (lásd \ref{sec:NTSC-PPU-frame}. függelék). A PPU ismertetése során már olvashattuk, hogy az eredeti állapotgépben található állapotokban négyszer annyi időt kell tölteni a hardvernek, a VGA jel kiadásának szinkronizálása miatt. Az állapotgépünk hat, az eredeti PPU-ban is megtalálható állapotra és egy SLEEP blokkoló állapotra bonthatjuk. A SLEEP állapot során a PPU és vele együtt az egész NES hardver egy blokkolt állapotba kerül. Ezalatt az idő alatt a CPU órajel képzését is blokkoljuk, így csak a pixel kétszerezés és a TMDS jelek kiadása zajlik. 
	
	\Aref{fig:bg-rendering-FSM}. ábrán látható hat alapállapot működése hasonlít az eredeti PPU állapotokhoz (lásd \ref{sec:NTSC-PPU-frame}. függelék):
	
	\begin{enumerate}
		\item \emph{Idle:} Minden képgenerálási sor első (nulladik) órajele egy \emph{Idle} állapot, itt a PPU nem végez memória elérést, csak cím regisztereket állít. Minden páratlan teljes kép generálása során, ez az állapot kihagyásra kerül (helyette az utolsó NT olvasás zajlik le).
		\item \emph{NT, névtáblák olvasása:} Ebben az állapotban kerülnek kiolvasásra a névtábla adatok. A fentebb látható állapotgépben még azt láthatjuk, hogy \aref{sec:NTSC-PPU-frame}. függelékben is látható módon, a 261. sor és a látható képtartomány (0-239. sor) végén, az állapotgép még két névtábla olvasást végez. %ezt nem értem
		\item \emph{AT, csempe attribútumok olvasása:} Ebben az állapotban a névtábla memóriából olvassuk ki a csempéhez tartozó attribútum adatokat. A későbbiekben ez határozza meg a csempe színeit.
		\item\emph{Pattern LSB (least significant byte):} A névtábla olvasás során megszerzett Pattern csempe cím használatával, egy csempe sor (8 pixel) adatainak, alsó 8 bitjének olvasása történik ebben az állapotban. (\aref{fig:Gumba-tile}. ábrán látható csempe egy sorának alsó bitjei).
		\item \emph{Pattern MSB (most significant byte):} A negyedik állapotban leírt olvasás, befejező lépése történik ebben az állapotban, tehát a felső 8 bit kiolvasása és mentése. Illetve ebben az állapotnak történik még a vertikális és horizontális VRAM címszámlálók növelése, \aref{sec:NTSC-PPU-frame}. függelékben látható helyeken (vörös négyzetek).
		\item \emph{VBLANK:} Ez az állapot az eredeti PPU vertikális kioltása, a legtöbb játék ezalatt az idő alatt végzi a PPU memória műveletek. Itt hozom létre a PPU státusz regiszter, VBLANK (IRQ) jelét. Ez jelez a NES CPU számára (NMI), hogy a VBLANK periódus elkezdődött (szabadon elkezdheti a memória műveleteket a PPU regisztereken keresztül). 
	\end{enumerate} 
	
	A Pattern olvasási állapotok nem csupán a háttér olvasását hanem a sprite adatok kiolvasását is végzik. \Aref{sec:NTSC-PPU-frame}. függelékben láthatjuk is, hogy a 257. képponttól a 320. képpontig történik a mozgó csempe adatok olvasása a következő aktív sorra, a sor többi részen pedig a háttér adatok olvasása történik.
	
	A PPU memória területeinek olvasását (NT, AT, PATTERN) úgy időzítem, hogy az adott állapot utolsó órajelére, kerüljön mentésre az éppen aktuális adat (felhasználható legyen). Ennek pontos időzítését \aref{code:saving-from-PPU Databus}. hardverleírásban olvashatjuk.
	
\begin{lstlisting}[caption={Az állapotgép alapján az adatok mentét vezérlőjelek}, label={code:saving-from-PPU Databus}, style=prettyverilog]
assign nametable_read = (bgrender_state == NT) & (x_rendercntr[2:0] == 3'b011);
assign attribute_read = (bgrender_state == AT) & (x_rendercntr[2:0] == 3'b011);
assign bg_lsb_read = (bgrender_state == BG_LSB) & (x_rendercntr[2:0] == 3'b011);
assign bg_msb_read = (bgrender_state == BG_MSB) & (x_rendercntr[2:0] == 3'b011);\end{lstlisting}
	
	\Aref{sec:NTSC-PPU-frame}. függelékben a 241. sorban látható VBLANK jel előállítása során különösen figyelni kellett az időzítésre. Mivel ennek a jelnek a hatására képződik a 6502-es CPU felé az NMI (non maskable interrupt) megszakítás (\aref{code:vblank-set}. hardverleírás, IRQ), amelynek pontos lefutása elengedhetetlen a játékok emulálása szempontjából. Az ehhez tartozó megszakításkezelő rutin tartalmazza általában azt a programkódot, amely a név (NT) memória területek frissítésért felelős. A pontos időzítést az FPGA projektben egy kétbites léptetőregiszter használatával állítom be, ezt és a vezérlőjelek képzését \aref{code:vblank-set}. hardverleírásban láthatjuk.       
		
\begin{lstlisting}[caption={VBLANK vezérlőjelek képzése és az NMI (IRQ) jel előállítása}, label={code:vblank-set}, style=prettyverilog]
//Driving the interupt flag
reg  interrupt_flag;
wire interrupt_clr;
always @ (posedge clk) 
begin
	if (rst || interrupt_clr || (status_rd && ph2_falling))
		interrupt_flag <= 1'b0;
	else
		if (vblank_set[2] && vblank[1])
			interrupt_flag <= 1'b1;
end
//NMI towards cpu
always @ (posedge clk) 
begin
	if (rst)
		irq <= 1'b0;
	else
		irq <= interrupt_flag & vblank_irq_enable; 
end
	
// vblank set signals
assign vblank_set[0] = (x_rendercntr == (FIRST_SCANLINE_PIXEL +  0)) & (y_renderingcntr == V_BLANK_BEGIN);
assign vblank_set[1] = (x_rendercntr == (FIRST_SCANLINE_PIXEL +  4)) & (y_renderingcntr == V_BLANK_BEGIN);
assign vblank_set[2] = (x_rendercntr == (FIRST_SCANLINE_PIXEL + 12)) & (y_renderingcntr == V_BLANK_BEGIN);

//Indicates the end of the VBLANK period.
assign vblank_clr    = (x_rendercntr == FIRST_SCANLINE_PIXEL +  4) & (y_renderingcntr == PRERENDERING_ROW);
assign interrupt_clr = (x_rendercntr == FIRST_SCANLINE_PIXEL + 12) & (y_renderingcntr == PRERENDERING_ROW);\end{lstlisting}
	
	\subsection{Mozgó csempe elemek - Sprite képalkotás}
	\label{sec:fpga-sprite-rendering}

	A PPU-ban található képalkotás második rétege a mozgó csempe elemek kiolvasása és feldolgozása az OAM memóriákból. Az eredeti hardver felépítéséről részletesen olvashatunk \aref{sec:OAM-memory}. fejezetben, az itt olvasottak alapján alakítottam ki a OAM memóriákat is az FPGA modulban. 
	
	Az elsődleges és a másodlagos OAM memóriát is elosztott memóriaként hoztam létre, a lehető leggyorsabb olvasási idő miatt. Az elosztott memória az FPGA LUT-jából közvetlenül leképeződő memória, általában olyan helyeken szokták alkalmazni, ahol kevés adatot kell tárolni és késleltetés mentes aszinkron olvasásra van szükségünk. A mi felhasználásunk során elengedhetetlen a késleltetésmentes adatkiolvasás, mert a háttér állapotgépet és a sprite állapotgépet szinkronizálni kell a Pattern adatok olvasása miatt.
	
	Az Sprite képalkotásban fontos szerepe van a DMA-ból érkező adat időben történő mentésének és ezzel párhuzamosan egy olyan elsődleges OAM RAM címzésnek, amely jól lekezeli a DMA-ból érkező adatokat és a sprite állapotgépben a másodlagos OAM memória feltöltését is. 
	
	A címképzésnek két fő módja van. Az első mód során, az elsődleges RAM címzését két mozgó számlálóval címezzük meg, m és n. Az m a négy bájtos sprite adatokon halad végig, amíg az n az elsődleges memóriában található 64 sprite-ot címzi meg, ezeknek a számlálóknak az időzítését a sprite állapotgéphez kötöttem. Ezt a címzési módot használom a másodlagos OAM memória töltése során, tehát a következő sorban aktív spritok keresésére. A második mód pedig a DMA működése során aktív cím, ez egy egyszerű fölfelé számláló, amely a CPU-tól kapja kezdő címét az OAM címregiszter írása során.
	
	Az így létrejövő két címet megfelelően multiplexálva kapjuk meg, az elsődleges OAM memória címzését. A cím képzését és az elsődleges OAM írását és olvasását \aref{code:Primary-oam}. hardverleírásban olvashatjuk részletesen.

\begin{lstlisting}[caption={Az elsődleges OAM RAM írása és olvasása}, label={code:Primary-oam}, style=prettyverilog]
(* ram_style = "distributed" *)
reg  [7:0]  pri_oam [255:0];
reg  [7:0]  pri_oam_addr;
wire [1:0]  pri_oam_addr_sel;
wire [7:0]  pri_oam_dout = pri_oam[pri_oam_addr];

always @(*) 
begin
	case (pri_oam_addr_sel)
		2'b01:   pri_oam_addr <= {n_cnt, m_cnt};
		2'b11:   pri_oam_addr <= {pri_oam_addr_cnt[7:3], n_cnt[0], m_cnt}; 
		default: pri_oam_addr <= pri_oam_addr_cnt; 
	endcase    
end

always @(posedge clk) 
begin
	if (oam_data_wr)
		pri_oam[pri_oam_addr] <= slv_mem_din;    
end\end{lstlisting} 

	Az sprite képgenerálás állapotgépének fontos eleme még a következő sorban aktív sprite-ok detektálásáért felelős hardveres egység, ezt \aref{code:Sprite-in-range}. hardverleírásban láthatjuk. Ennek alapja, hogy az állapotgép alapján képzett vezérlőjellel (oam\_temp\_reg\_wr) elmentjük az éppen aktív OAM sprite vertikális pozíció értékét és az éppen aktív sor értékből kivonva egy vertikális különbség értéket képzünk. Ezt vizsgálva a 8x8 és 8x16-os spritok esetére, detektálhatjuk, hogy az éppen aktív sprite a következő sorban megjelenik-e. Abban az esetben, ha találtunk egy megjelenítendő sprite-ot akkor az állapotgép alapján (\ref{fig:sprite-rendering-FSM}. ábra) továbblépve ezt mentjük a másodlagos memóriába, vagy még egyel növeljük a túlcsordulás jelzőt. 

\begin{lstlisting}[caption={A következő kép generálási sorban aktív sprite-ok jelzése}, label={code:Sprite-in-range}, style=prettyverilog]
reg  [8:0]  y_diff_reg1;
wire      sprite_in_range = (sprite_size) ? (y_diff_reg1[8:4] == 5'd0) : (y_diff_reg1[8:3] == 6'd0);


// if I subtract from scanline cntr - tile_addr then check the upper bits of y_diff_reg to be zero then we have a sprite in range
always @(posedge clk) 
begin
	if (rst)
		y_diff_reg1 <= 9'd0;
	else
		if (oam_temp_reg_wr)
			y_diff_reg1 <= scanline_cnt - {1'b0, pri_oam_dout};    
end\end{lstlisting}

	\begin{figure}[H]
	\centering
	\includegraphics[width=125mm, keepaspectratio]{figures/sprite-rendering-FSM-v3}
	\caption{Sprite képalkotás és memória olvasást vezérlő állapotgép} 
	\label{fig:sprite-rendering-FSM}
	\end{figure} 

%ez nem egy korábbi fejezet volt az eredeti hardver megértése?
	 Az eredeti sprite feldolgozás menete négy fő részre bontható, ez \aref{sec:NTSC-PPU-frame}. függelékben is látható. 	
	
	\begin{enumerate}
		\item A nyolc előző sorban mentett sprite törlése (1-64 órajel). \Aref{fig:sprite-rendering-FSM}. állapotgépben ez az IDLE állapot.
		\item Az elsődleges OAM RAM végigolvasása aktív sprite-okat keresve. Minden egyes páratlan órajel során olvassa az adatokat, a párosok alatt pedig írja őket a memória területre. Ha aktív sprite-ot találunk a négy bájtját mentjük a másodlagos OAM RAM-ba (65-256 órajel). \Aref{fig:sprite-rendering-FSM}. állapotgépben ez sorrendben az Y koordináta másolása, csempe cím másolása, csempe attribútum másolása és X koordináta másolása állapotoknak felel meg.
		\item Ha megtalált nyolc aktív sprite-ot, akkor tovább keres, hátha túlcsordulást érzékel. Itt a memória olvasásban egy hardveres hiba található, mivel ha talált egy extra aktív sprite-ot is akkor a következő sprite-ok Y koordinátája helyett a sorban következő bájtot (csempe cím) vizsgálja a rendszer. Ha ezt követően is talál még egy aktív sprite-ot, akkor pedig az ezt követő sprite bájtokat kezdi el vizsgálni (csempe attribútum) (65-256 órajel). \Aref{fig:sprite-rendering-FSM}. állapotgépben ez a négy túlcsordulási állapotnak felel meg.
		\item Végül az utolsó lépésben az aktív sprite adatok kiolvasása és mentése következik (257-320 órajel). \Aref{fig:sprite-rendering-FSM}. állapotgépben ez a három sprite adat olvasási állapotnak felel meg.
	\end{enumerate}

	\Aref{fig:sprite-rendering-FSM}. ábrán látható állapotgép két extra állapottal bővül ki az FPGA rendszer szinkronizációja miatt. Az első két állapot (OAM IDLE és SCANLINE WAIT) a VGA jel generálás alatti IDLE állapotot reprezentálja (hasonlóan \aref{fig:bg-rendering-FSM}. SLEEP állapotához). Illetve a HBLANK WAIT állapot, amely a túlcsordulás figyelést követően szinkronizálja, az állapotgép működését.

	Az állapotgép negyedik szakasza teljes mértékben szinkron működik a háttér képalkotást vezérlő állapotgép Pattern adat olvasásával. Az innen kiolvasott két bájtos csempe adatokat egy-egy pufferbe mentjük, ha kevesebb mint 8 aktív sprite van egy sorban, akkor a fennmaradó puffer területek nullás értéket kapnak. A pufferek léptetőregiszterként tárolják a csempe adatokat és figyelik a képalkotás horizontális számlálóját, ha az aktuális sprite X koordinátája megegyezik a sor indexszel, akkor elkezdődik a 8 pixelnyi képadat léptetése és kiadása. Ha a $sprite\_clipping$ jel aktív akkor az első csempe oszlop (8 pixel) időtartalma alatt nem történhet mozgó csempe megjelenítés, tehát ezeknek a sprite-oknak az értéke nullázódik. %ezt nem értem
	Ennek segítségével tudunk szép folyamatos bal oldali görgetést létrehozni.
	
	Végül a pufferekből érkező sprite pixelei között meghatározzuk a prioritási sorrendet és a nagyobb prioritással rendelkező pixel adatait adjuk ki a sprite képalkotási modulból. A prioritást az elsődleges OAM memóriában való elhelyezkedés határozza meg, a nulladik sprite-nak van a legnagyobb prioritása és a 63.-nak pedig a legkisebb (tehát minél előbb kerül a másodlagos OAM-ba a sprite annál nagyobb a prioritása).
	
	A játékok hibátlan emulálása szempontjából elengedhetetlen még a $sprite_0\_hit$ vezérlőjel pontos előállítása. Ha ezt nem pontosan hozzuk létre, egyes játékok, többek között a Super Mario Bros. a kezdő képernyőn ragad és nem kezd el futni a teljes szoftver (valószínűleg egy várakozó állapotban ragad a program). A jel egyik komponensét a $sprite_0\_visible$ jelet, a sprite képalkotást vezérlő modulon belül, \aref{code:sprite0-visible}. hardverleírásban látható módon hozom létre. A végső $sprite_0\_hit$ jel pedig a logikai és kapcsolata, a $sprite_0\_visible$, $visible\_bg\_pixel$ és a $sprite_0\_check$ jeleknek. A látható háttér pixel, a nem átlátszó háttér pixeleket vizsgálja, a $sprite_0\_check$ pedig azt, hogy a horizontális képalkotás elért-e a 255. pixelig. %ezt nem értem

\begin{lstlisting}[caption={A $sprite_0\_visible$ vezérlőjel előállítása}, label={code:sprite0-visible}, style=prettyverilog]
reg [1:0] sprite0_in_range;
assign sprite0_visible = sprite0_in_range[1] & |sprite_pixel[1:0] & ~(~sprite_enabled | (first_column & ~no_sprite_clip)); 

always @(posedge clk) 
begin
	if (rst)
		sprite0_in_range <= 2'd0;
	else
		if (scanline_begin)
			sprite0_in_range <= {sprite0_in_range[0], 1'd0};
	else
		if (odd_phase_en && (oam_state == OAM_COPY_X_COORD) && (n_cnt == 6'd0))
			sprite0_in_range <= {sprite0_in_range[1], 1'b1};
end\end{lstlisting} 

	\subsection{PPU adatbusz és memória elérése}
	
	A PPU működéséhez elengedetlen a VRAM cím regiszterének képzése is, ennek felépítése kétrétegű (az eredeti PPU mintájára). Az első réteg \aref{sec:CPU-databus-ppu_reg}. fejezetben leírtak alapján a CPU adatbuszról érkező regiszter írások hatására regiszterekbe menti a VRAM címrészleteket, ennek a pontos változásai \aref{fig:2000-2005-2006-ppu-reg-writes}. ábrán láthatók (t regiszterként). A második réteg pedig a képgenerálás során képződő számlálást és a soron kívüli regiszter töltéseket és fölfelé számolásokat foglalja magába (\aref{fig:2000-2005-2006-ppu-reg-writes}. ábrán v regiszternek felel meg).
	
	A címszámláló réteg különleges olyan szempontból, hogy megkülönböztet két fajta felfelé számolási sorrendet. Az első a standard számlálás, amikor a cím két része a horizontális és a vertikális külön-külön számolnak felfelé, mint két különálló regiszter. Ezt a számlálási módot használja a PPU \aref{sec:NTSC-PPU-frame}. függelékben látható vörössel kiemelt pixelek megjelenítése során, tehát az általános képgeneráláskor. A második számlálási mód esetén a VRAM írása vagy olvasása hatására egy felfelé számlálás történik, itt a teljes VRAM címregiszter számol fölfelé 1-et vagy 32-t a (a számlálási mód függvényében). 
	
	\begin{figure}[H]
	\centering
	\includegraphics[width=150mm, keepaspectratio]{figures/2000-2005-2006-ppu-reg-writes}
	\caption{VRAM cím regiszter értékadása (eredeti PPU)} 
	\label{fig:2000-2005-2006-ppu-reg-writes}
	\end{figure} 
	
	A \ref{sec:NT-AT-mirroring}. fejezetben leírtak alapján a VRAM címszámláló regiszterekből hozom létre a név tábla és attribútum tábla címeit. Majd az NT  állapotban kiolvasott Pattern cím adatok segítségével létrehozom a háttér csempeadatok olvasási címét. A sprite állapotgépből érkező adatok alapján a $sprite\_size$-nak megfelelően állítom elő sprite Pattern címeket, a 8 aktív csempeadat kiolvasása számára. A pontos címképzéseket \aref{code:VRAM-addr}. hardverleírásban olvashatjuk.
	
\begin{lstlisting}[caption={VRAM cím képzése a számlálókból és az állapotgépek alapján}, label={code:VRAM-addr}, style=prettyverilog]
wire [13:0] ppu_nt_addr = {2'b10, v_cnt, h_cnt, vt_cnt, ht_cnt};
wire [13:0] ppu_at_addr = {2'b10, v_cnt, h_cnt, 4'b1111, vt_cnt[4:2], ht_cnt[4:2]};
wire [13:0] bg_lsb_addr = {1'b0, background_pattern_sel, tile_index_reg, 1'b0, fv_cnt};
wire [13:0] bg_msb_addr = {1'b0, background_pattern_sel, tile_index_reg, 1'b1, fv_cnt};

assign sprite_lsb_addr = (~sprite_size) ? ({1'b0, sprite_pattern_sel, sprite_tile_index, 1'b0, sprite_range[2:0]}) : ({1'b0, sprite_tile_index[0], sprite_tile_index[7:1], sprite_range[3], 1'b0, sprite_range[2:0]});
assign sprite_msb_addr = (~sprite_size) ? ({1'b0, sprite_pattern_sel, sprite_tile_index, 1'b1, sprite_range[2:0]}) : ({1'b0, sprite_tile_index[0], sprite_tile_index[7:1], sprite_range[3], 1'b1, sprite_range[2:0]});\end{lstlisting}

	A PPU (mester) busz cím regiszterének meghajtása során figyelembe kell vennünk azt, hogyha a chipen bármilyen VRAM elérést hajtanak végre, akkor a címregisztert ne a VRAM címszámláló rétegéből határozzuk meg, hanem egy extra regiszteren a $vram\_addr\_reg$-en keresztül adjuk ki, ezzel késleltetve a címünket egy órajellel. Ez az eredeti NES PPU-ban is egy hardveres hiba volt, amit játékok fel is használtak (például a Super Mario Bros.). Abban az esetben is, ha a háttér vagy a sprite képalkotás nincs kiválasztva tehát $ppu\_enable$ inaktív, automatikusan a késleltetett VRAM címet kell kiadni. 
	
	A végső cím kimenetet még szinkronizálnunk kell a chip többi részéhez, erre szolgál az $addr\_reg\_ld$ jel. A busz címregiszterének képzését \aref{code:PPU-master-databus-addr}. hardverleírásban láthatjuk részletesebben.

\begin{lstlisting}[caption={PPU master adatbusz címregiszterének meghajtása és időzítése}, label={code:PPU-master-databus-addr}, style=prettyverilog]
wire vram_address_sel = (vram_state_machine_sel == VRAM_RD_WAIT) || (vram_state_machine_sel == VRAM_WR_WAIT);
wire [7:0] ppu_address_sel;
wire addr_reg_ld = (x_rendercntr[2:0] == 2'b100);

assign ppu_address_sel [0] = vram_address_sel;
assign ppu_address_sel [1] = (bgrender_state == NT);
assign ppu_address_sel [2] = (bgrender_state == AT);
assign ppu_address_sel [3] = (bgrender_state == BG_LSB) & sprite_read;
assign ppu_address_sel [4] = (bgrender_state == BG_MSB) & sprite_read;
assign ppu_address_sel [5] = (bgrender_state == BG_LSB) & ~sprite_read;
assign ppu_address_sel [6] = (bgrender_state == BG_MSB) & ~sprite_read;
assign ppu_address_sel [7] = ppu_enable;

always @(posedge clk) 
begin
	if (rst)
		ppu_mem_addr <= 14'd0;
	else
		if (addr_reg_ld)
			case (ppu_address_sel)
				8'b10000010 : ppu_mem_addr <= ppu_nt_addr;
				8'b10000100 : ppu_mem_addr <= ppu_at_addr;
				8'b10001000 : ppu_mem_addr <= sprite_lsb_addr;
				8'b10010000 : ppu_mem_addr <= sprite_msb_addr;
				8'b10100000 : ppu_mem_addr <= bg_lsb_addr;
				8'b11000000 : ppu_mem_addr <= bg_msb_addr;
				default		: ppu_mem_addr <= vram_addr_reg;
			endcase
end\end{lstlisting}

	\subsection{A PPU képgenerálás működése}
	
	A háttér állapotgép működése során kiolvasott csempe adatok feldolgozása hasonlít a sprite pixel feldolgozásra, azzal a különbséggel, hogy ennek folyamatosnak kell lennie a háttér képalkotás ideje alatt. Ezt az FPGA modulon belül egy különleges hardveres elemmel, egy LUT-ban szintetizálódó léptetőregiszterrel, SRL-el (shift register LUT) oldottam meg. %szerintem itt zárójelezni kell az srl-től kezdve
	Az általános léptetőregiszterekhez képest ebben az elemben a teljes regiszter töltése nem engedélyezett, csak a regiszterek bitszélességével történő egy bites léptetéses töltés. %ezt nem érte
	Ennek előnye, hogy könnyen összeszinkronizálható a háttér csempék két bájtja (mivel az LSB és MSB bájtok bit párjai alkotják a háttér egy pixelét). A regiszterek kimeneteként pedig bármelyik bitpár kiválasztható. A kimenet választás azért fontos, mert a görgetés során egy csempét pixelekként szeretnénk kigörgetni a megjelenített képtartományból. Ilyen SRL-t használtam a csempe attribútumának megjelenítésére is. Ezt az adatfeldolgozó láncot olvashatjuk \aref{code:SRL-shiftregs}. hardverleíró részletben.
	
	\begin{figure}[H]
	\centering
	\includegraphics[width=120mm, keepaspectratio]{figures/NES-render-chamber}
	\caption{A NES PPU-jának pixel feldolgozó egysége} 
	\label{fig:NES-render-chamber}
	\end{figure} 
	
	Az állapotgépek pixel feldolgozó egysége és működése nagyban hasonlít az eredeti hardver felépítésére, ezt \aref{fig:NES-render-chamber}. ábrán láthatjuk. A PPU két állapotgépe (háttér és sprite) során kapott pixel adatok összefűzésének és feldolgozásának három fő fázisa van: %ezt nem értem
	
	\begin{enumerate}
		\item \emph{Prioritás vizsgálat, végső pixel meghatározása:} A sprite képalkotás kétféleképpen történhet: a mozgó csempe elem kerülhet a háttér elé, illetve a háttér mögé. Erről a csempe prioritása dönt (ha 1 akkor a háttér mögé kerül a mozgó elem), ennek segítségével alkották meg a játékfejlesztők például a Mario húsevő növényeit. A pixel kiválasztás során még figyelembe kell venni hogy a háttér pixel átlátszó-e, ebben az esetben mindenképpen a sprite képkockáját válasszuk. Ezt a kiválasztási folyamatot láthatjuk \aref{code:SRL-shiftregs}. hardverleíró részlet alján.
		\item \emph{Paletta lookup táblázat:} Az így kiválasztott pixel egy paletta címet képez, a NES CPU-ja által feltöltött Paletta lookup táblázatban. Ennek működéséről olvashattunk \aref{sec:Pattern-tables-and-palettes}. fejezetben. Az FPGA-ban történő megvalósítás során elosztott memóriát használtam, a késleltetés mentes olvasás miatt. A helyes emulálás során különösen figyelnünk kell a memória területek helyes tükrözésére, ha ezt nem jól implementáljuk egyes játékok színei nagyban eltérhetnek az eredetitől, például a Mario háttere kék helyett fekete lesz. Ennek helyes implementálását olvashatjuk \aref{code:palette-mirroring}. hardverleírásban. Ha a $BG\_clipping$ jel aktív és az első csempe oszlopban vagyunk, vagy a PPU várakozó állapotban van (\ref{fig:bg-rendering-FSM}. SLEEP állapota), akkor automatikusan egy fekete pixel értékével helyettesítjük a palettából olvasott címet.
		\item \emph{RGB blokk ROM:} Az FPGA implementálás során a paletta memóriából kiolvasott színértéket egy címként értelmeztem. Ennek feldolgozásához készítettem egy RGB adatokkal előre feltöltött ROM-ot, amely a címhez a megfelelő 24 bites RGB értéket rendeli. Itt még figyelembe vettem a NES képalkotást befolyásoló két funkciót. Az első a monokróm mód, amely fekete fehér képalkotást tesz lehetővé. Ezt úgy implementáltam, hogy a palettából kiolvasott cím, hue értékének megfelelő biteket nullával helyettesítem. A második ilyen mód pedig, a szín kiemelés (a PPU képes volt, adott színek kiemelésére és a többi szín elsötétítésére). Ezt a tulajdonságot úgy implementáltam, hogy a Paletta ROM címébe beletartoznak az $emphesize\_r / -\_g / -\_b$ jelek, így egy kicsit nagyobb blokk ROM-ot képezve a hardverben.
	\end{enumerate} 
	
\begin{lstlisting}[caption={Pixel adat feldolgozó SRL léptetőregiszterek}, label={code:SRL-shiftregs}, style=prettyverilog]
//LSB of backgorund pixel
reg [7:0] bg_lsb_buff_reg;
always @ (posedge clk) 
begin
	if (rst)
		bg_lsb_buff_reg <= 8'd0;
	else
		if (bg_msb_read)
			bg_lsb_buff_reg <= bg_lsb_reg; // shift reg
		else if ((x_rendercntr[1:0] == 2'b11) && (x_rendercntr > START_OF_SHIFT) && (x_rendercntr <= END_OF_SHIFT) && ~(bgrender_state == VBLANK))
			bg_lsb_buff_reg <= {bg_lsb_buff_reg[6:0], 1'b0}; 
end
reg [7:0] shr_lsb_render = 8'd0;
wire	  bg_lsb_out;  
always @(posedge clk) 
	if ((x_rendercntr[1:0] == 2'b11) && (x_rendercntr > START_OF_SHIFT) && (x_rendercntr <= END_OF_SHIFT) && ~(bgrender_state == VBLANK))
		shr_lsb_render <= {shr_lsb_render[6:0], bg_lsb_buff_reg[7]};
assign bg_lsb_out = shr_lsb_render[~fh_reg];
//MSB of background pixel
reg [7:0] shr_msb_render = 8'd0;
wire	  bg_msb_out;  
always @(posedge clk) 
	if ((x_rendercntr[1:0] == 2'b11) && (x_rendercntr > START_OF_SHIFT) && (x_rendercntr <= END_OF_SHIFT) && ~(bgrender_state == VBLANK))
		shr_msb_render <= {shr_msb_render[6:0], bg_msb_reg[7]};
assign bg_msb_out = shr_msb_render[~fh_reg];

//0 bit of attribute
reg [7:0] shr_attr0_render = 8'd0; 
always @(posedge clk) 
	if ((x_rendercntr[1:0] == 2'b11) && (x_rendercntr > START_OF_SHIFT) && (x_rendercntr <= END_OF_SHIFT) && ~(bgrender_state == VBLANK))
		shr_attr0_render <= {shr_attr0_render[6:0], tile_attr_reg_saved[0]};
wire shr_attr0_out = shr_attr0_render[~fh_reg];
//1 bit of attribute
reg [7:0] shr_attr1_render = 8'd0; 
always @(posedge clk) 
	if ((x_rendercntr[1:0] == 2'b11) && (x_rendercntr > START_OF_SHIFT) && (x_rendercntr <= END_OF_SHIFT) && ~(bgrender_state == VBLANK))
		shr_attr1_render <= {shr_attr1_render[6:0], tile_attr_reg_saved[1]};
wire shr_attr1_out = shr_attr1_render[~fh_reg];

//pixel output
reg [3:0] bg_pixel;
always @(posedge clk) 
begin
	if (rst)
		bg_pixel <= 4'b0;
	else
		bg_pixel <= {shr_attr1_out, shr_attr0_out, bg_msb_out, bg_lsb_out};		
end
wire [4:0] palette_addr = 	(sprite_priority & visible_bg_pixel) ? ({1'b0, bg_pixel}) : ({1'b1, sprite_pixel});\end{lstlisting}

\begin{lstlisting}[caption={A paletta címek tükrözése}, label={code:palette-mirroring}, style=prettyverilog]
wire [4:0] palette_ram_nt_addr_mirrored = {vram_addr_cnt[4] & |vram_addr_cnt[1:0], vram_addr_cnt[3:0]};									
wire [4:0] palette_ram_addr_mirrored = {palette_addr[4] & |palette_addr[1:0], palette_addr[3:0]};\end{lstlisting}

	\subsection{A VGA képalkotás}
	
	A PPU véső hardveres eleme az RGB adatokat tároló és megjelenítő VGA modul, ennek felépítését láthatjuk \aref{fig:vga-rendering-top}. ábrán. 
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=120mm, keepaspectratio]{figures/vga-top-diagram}
		\caption{VGA top modul blokkvázlata} 
		\label{fig:vga-rendering-top}
	\end{figure} 

	A PPU bemutatása során \aref{sec:PPU-FPGA}. fejezetben már megismertük a chip áttervezésének alapötletét. Ezek alapján a PPU egy képalkotási sora alatt (1600 órajel) a pixeleket minden második órajelben mintavételezve kapjuk meg a 800 pixel széles VGA kép egy sorát. Majd a következő képsor mintavételezése alatt, az előzőekben mintavételezett kép sort kétszer kiadva hozzuk létre az eredeti NES pixelek nagyítását. Így kapjuk meg a 640x480-as VGA kép két sorát. Így a VGA kép egy sor késésben lesz a PPU képalkotáshoz képest, viszont helyes indulási időzítések mellett, ez nem észrevehető. Puffereket egy-egy kilobájtnyi blokk RAM-ként alakítottam ki a VGA modulon belül, mivel az így kiolvasott adatok egy órajelnyi késleltetése nem okoz semmilyen extra csúszást a VGA időzítésben. Ez a dupla pufferelés látható \aref{fig:vga-rendering-top}. ábrán is, természetesen ezek közül egyszerre csak az egyik puffer kimenet aktív és a két puffer kimenetei dinamikusan váltják egymást a PPU-ban történő képsorok számának növekedésével.
	
	A TMDS jeladó és a pufferek töltésének kezdetét vezérlőjelek időzítése különösen fontos, hiszen ezek segítségével vagyunk képesek a PPU aktív képtartományát pozicionálni a VGA pixel sor közepére. A pixel kétszerezést követően a PPU aktív képtartománya 512 pixel órajelig tart. Tehát A helyes időzítéshez 64 pixel órajelig fekete pixelt kell a TMDS adónak venni, majd következik az 512 pixelnyi aktív rész, végül pedig 224 képkockányi fekete pixel, ez a tartomány tartalmazza a horizontális kioltási területeket is. Ezt a képkocka arányt határozza meg \aref{fig:bg-rendering-FSM}. háttér állapotgépben, a SLEEP állapotból történő kilépés időzítése. Illetve a puffer töltés kezdetének meghatározásával, még finomhangolható a kép pontos beállítása. Ahhoz, hogy a kezdetektől fogva helyes kép jelenjen meg a monitorunkon, a VGA szinkronizálási jelek generálását is kellett késleltetnem a pre-rendering sor és az első puffer feltöltésének idő tartalmával. Ezt az időzítést egy reset jelre nullázódó számláló segítségével oldottam meg, amely 3201 pixel órajelet (két teljes PPU sor + 1 pixel órajel) követően engedélyezi a generálást. A szinkronizációs jelek pontos időzítése a pixel órajelhez képest \aref{code:vga-timing}. hardverleírásban látható. 
	
\begin{lstlisting}[caption={A képgenerálás időzítési paraméterei}, label={code:vga-timing}, style=prettyverilog]
localparam H_BLANK_BEGIN     = 10'd639;
localparam H_SYNC_BEGIN      = 10'd655;
localparam H_SYNC_END        = 10'd751;
localparam H_BLANK_END       = 10'd799;

localparam V_BLANK_BEGIN     = 10'd479;
localparam V_SYNC_BEGIN      = 10'd489;
localparam V_SYNC_END        = 10'd491;
localparam V_BLANK_END       = 10'd523;\end{lstlisting}
	
	TMDS adók két fő elemből épülnek fel. Minden színcsatorna tartalmaz egy 10 bites TMDS kódolót, amely az RGB adatokat, csatornánként (8 bit) egy 10 bites kiadható jellé kódolja. Ezek közül egyedül a kék színcsatorna tartalmazza a hsync, vsync jeleket. Majd ezt követően, ezeket a 10 bites adatokat öt az egyhez sorosítókon (OSERDES) keresztül egy-egy kimeneti puffer (OBUF) alakítja át a differenciális p és n jelekké. Az OSERDES vezérlő strobe-ja 50 MHz-en működik, a kiadott bitek pedig 250 MHz-el jönnek. A VGA jel szinkronizációs jeleiről és a TMDS adók működéséről részletesebben  \acite{vgalogsys} irodalomban olvashatunk, ennek alapján hoztam létre én is a TMDS jeladót.

\section{NES memória felépítése az FPGA-ban}

A memória menedzser modul fejlesztése, során \aref{sec:fpga-desing-begining}. fejezet bevezetésében leírt alapelveket követve, az egyszerűséget és a gyors, könnyű tesztelhetőséget előtérbe helyezve, a játék kazettákon található karakter és program ROM-okat is a modulon belül blokk ROM-ként helyeztem el. \Aref{sec:fpga-nes-board-summary}. FPGA kártya ismertetése során kitértem a Spartan-6-ban található blokk RAM-ok számára, ez 32 db 8 kilobites blokk RAM (64 kilobájt). A NES FPGA hardverhez, legnagyobb mapper chip nélküli játék esetén a következő memória területek szükségesek:

\begin{itemize}
	\item 32 kilobájt program ROM (játék kártya), 
	\item 8 kilobájt CH ROM (játék kártya),
	\item 2 kilobájt cpu work RAM (alaplap),
	\item 2 kilobájt név tábla memória (alaplap),
	\item 2 kilobájt vga képalkotás pufferek (PPU),
	\item 512 * 3 bájt paletta RAM (PPU).
\end{itemize}

A fentebbiekből kiszámolható, hogy a kezdeti teszteléshez nem szükséges, hogy a játék kártyák memória területét SRAM-ban helyezzem el, mivel a Super Mario Bros. esetén is (32 kilobájt program ROM), még marad 16 kilobájt blokk RAM a hardverben. Ennek az egyszerűsítésnek a segítségével a teszteléshez nem kell lefejleszteni a 6502-es processzorhoz egy UART interfészt (és az ehhez szükséges szoftvereket), hogy ezen keresztül töltsük fel a SRAM memória területeit a játékprogram indítása előtt. 

A játék kártyákon található ROM területek implementálása során figyelembe vettem, hogy a blokk RAM-jaim elérési ideje ugyanakkora legyen, mintha az SRAM-ot érnénk el, így a jövőben könnyen kiegészíthetővé és cserélhetővé válik ez a hardveres modul. Az egységesítés miatt az NT RAM elérési idejét is ugyanennyire állítottam be, így a PPU memória eléréseinek időzítése során csupán egyféle időzítésre kellett figyelnem. Ez a gyakorlatban azt jelentette, hogy a memória olvasások két órajel késleltetéssel jelennek meg a kimeneten, az írások pedig egy órajel időtartam alatt valósulnak meg (ez megfelel az SRAM 10 ns-os elérési idejének). Az olvasás késleltetését egy pufferregiszterrel valósítottam meg.

A memória menedzser teljes adatbusz interfészeket implementál, ami azt jelenti, hogy a teljes címet megkapja a CPU (16 bit) és a PPU (14 bit) felől a modul. A különböző memóriák kiválasztása és címének meghatározása \aref{tab:PPU-memory}. és \ref{tab:CPU-Memory}. táblázatok alapján \aref{code:memory-addresing}. hardverleírásban olvasható.

\begin{lstlisting}[caption={A memória menedzserben található memória területek címzése}, label={code:memory-addresing}, style=prettyverilog]
wire [10:0]	cpu_work_ram_addr = cpu_addr[10:0];			 	 //cpu inner memory access
wire		cpu_work_ram_sel  = (cpu_addr[15:13] == 3'b000); //0x0000-0x07FF and the mirrors until 0x1FFF

wire [14:0]	cpu_prog_rom_addr = cpu_addr[14:0];			 
wire		cpu_prog_rom_sel  = cpu_addr[15]; 

wire [11:0]	ppu_name_table_addr = {ppu_name_table_addr_h, ppu_addr[9:0]};
wire		ppu_name_table_sel = ppu_addr[13];

wire [12:0] ppu_ch_rom_address = ppu_addr[12:0];
wire		ppu_ch_rom_sel = ~ppu_addr[13];\end{lstlisting}

A jövőbeli könnyebb kibővíthetőség érdekében a PPU névtábla tükrözései közül az összeset implementáltam, illetve fenntartottam egy extra helyet különlegesebb mapper-ek tükrözései számára. Jelenleg a tükrözést a modulban egy paramétereként állíthatjuk, de a jövőben ezt a mapper chip, illetve a játék program fogja állítani. A tükrözések működéséről és felhasználásáról részletesebben olvashatunk \aref{sec:NT-AT-mirroring}. fejezetben, ezek implementálását pedig, \aref{code:nt-address-mirroring}. hardverleírásban láthatjuk. 

\begin{lstlisting}[caption={A PPU görgetéshez használt névtábla tükrözés}, label={code:nt-address-mirroring}, style=prettyverilog]
reg  [1:0] 	ppu_name_table_addr_h;
reg	 [1:0]	mapper_mirroring; //in the future if we have a mapper

always @ (*)
begin
	case (NT_MIRRORING)
		// Horizontal Mirroring
		2'b00: ppu_name_table_addr_h <= {1'b0, ppu_addr[11]};
		// Verical Mirroring
		2'b01: ppu_name_table_addr_h <= {1'b0, ppu_addr[10]};
		// Mappers Mirroring
		2'b10: ppu_name_table_addr_h <= mapper_mirroring;
		// Four-screen mirroring 
		2'b11: ppu_name_table_addr_h <= {ppu_addr[11:10]};
	endcase
end\end{lstlisting}

%phi?
A CPU memória elérésének csupán a blokk RAM egy órajeles késleltetése van, viszont az adatbusz meghajtása során figyelni kell, hogy a $\phi_2\_falling$ jel hatására nullába kell állítanunk a modul kimenetét (a top modulban az adatbuszok összefűzésének érdekében).

\section{DMA - FPGA megvalósítása}

Az eredeti DMA működéséről \aref{sec:DMA}. fejezetben olvashatunk. A DMA modul létrehozása során a legnagyobb kihívást a pontos időzítés megvalósítása jelentette. \Aref{fig:FPGA-toplevel-diagram}. ábrán is látható módon, ha a DMA-t eléri a CPU, akkor ezt követően a DMA átveszi a CPU adatbuszát, viszont ennek szinkronban kell végbemennie a többi hardveres elem miatt. Ennek megoldása érdekében a modul egy speciális bemenettel rendelkezik, amely a CPU órajel ciklusának paritását vizsgálja. \Aref{fig:sprite-dma-FSM}. ábrán szemléltetett állapotgépben látható is, hogy ez az órajel illesztést egy speciális késleltetéssel oldottam meg, ha páratlan ciklusban érkezett a CPU kérése akkor két teljes CPU órajelet várunk, ha párosban akkor csak egyet. Ezzel pontosan annyi ciklus időt hagyva a processzor számára, hogy befejezze a jelenlegi feladatait.

A CPU adatbuszt a processzor ready jelének elvételével és a DMA $valid\_address$ vezérlőjel egybe állításával veszi el. A többi része az adatbusznak egyszerű logikai vagy műveletek segítségével összevonható \ref{code:cpu-data-bus}. hardverleírás. 

\begin{figure}[H]
\centering
\includegraphics[width=100mm, keepaspectratio]{figures/sprite-dma-FSM}
\caption{OAM DMA működési állapotgépe} 
\label{fig:sprite-dma-FSM}
\end{figure}

Ezt a szinkronizációs problémát leszámítva a hardver működése egyszerű. A CPU a DMA elérése során egy címet ad az eszköznek, amely a CPU munka memóriájának egy területére mutat, általában \$0200. Majd innen az olvasási és írási állapotok váltakozásával 64 * 4 bájt memória mennyiséget olvas és ír (a teljes elsődleges OAM memóriát). Az írás a PPU \$2004-es OAM data regiszterére történik, ennek feldolgozását \aref{sec:fpga-sprite-rendering}. fejezetben olvashatjuk.

A memória terület másolását követően az eszköz visszaadja a CPU címbuszát és master adatbusz kimeneteit visszaállítja nullára, ezzel elengedve a CPU adatbuszt. %itt a ragozás nem jó

Egy DMA ciklus teljes szimulációját \aref{fig:Full-dma-working-in-simulation}. ábrán láthatjuk, már itt is megfigyelhető, hogy a ready jel elvételét követően a DMA címbusza elkezd adni és ezek az értékek kerülnek ki a CPU összesített címbuszára. \Aref{fig:Working-dma-in-simulation}. szimulációs ábrán pedig egy DMA ciklus kezdetét láthatjuk. Itt nyomon követhetjük a címbuszok pontos tartalmát. Tehát láthatjuk, hogy a DMA \$0200 címről kezd el olvasni (ezt a címet ciklusonként növeli) és a \$2004-es címre pedig ír. Az írás és olvasás váltakozását pedig az RNW jel váltakozása mutatja. 

\begin{figure}[H]
	\centering
	\includegraphics[width=150mm, keepaspectratio]{figures/Working-dma-in-simulation}
	\caption{A DMA ciklus kezdete szimulációban} 
	\label{fig:Working-dma-in-simulation}
\end{figure} 

\begin{figure}[H]
	\centering
	\includegraphics[width=150mm, keepaspectratio]{figures/Full-dma-working-in-simulation}
	\caption{Teljes DMA ciklus szimuláció} 
	\label{fig:Full-dma-working-in-simulation}
\end{figure} 

\section{6502 processzor működése az FPGA rendszerben}

A PPU és az eddig elkészített hardveres elemek tesztelhetősége végett a projekt ezen fázisában inkább különböző nyílt forráskódú (Open Source) processzorokat próbáltam a rendszerbe illeszteni. Itt nagy segítségemre volt az OpenCores nevű weboldal \cite{OpenCore}, amely különböző nyílt forráskódú processzorok és hardveres eszközök hardverleírását tartalmazza. Illetve a szintén nyílt forráskódú Mister NES projekt \cite{MisterNES}, amely rendelkezik egy VHDL nyelven íródott processzorral. Ezek forráskódjai, azért nem tökéletesek, sok módosításra és javításra szorulnának a meglévő rendszerbe történő illesztésük során. Ez nagyon időigényesnek érződött, ezért konzulensemhez fordultam segítségért. Szerencsére Raikovitch Tamás el tudott látni egy általa készített és a karbantartott 6502-es processzor Spartan-6-osra szintetizált és implementált processzor binárisával a tesztelésekhez. Ez egy régebbi projektje során használt megbízható processzor implementációnak bizonyult, amelyet könnyen be tudtam illeszteni az eddig implementált rendszerbe. \Aref{fig:working-cpu-simulation}. szimulációs ábrán jól látható, hogy a rendszer helyesen olvassa be a Super Mario első utasítását, ez körülbelül a kép közepén a $cpu\_din$ csatornáján, 78-as (hexa) assembly kód. 

\begin{figure}[H]
	\centering
	\includegraphics[width=150mm, keepaspectratio]{figures/working-cpu-simulation}
	\caption{A CPU szimulációja működés közben, Super Mario Bros. első assembly kódjának olvasása} 
	\label{fig:working-cpu-simulation}
\end{figure} 

A CPU-nak köszönhetően a tesztelések során biztos lehettem abban, hogy csak az általam létrehozott rendszerben van hiba és a processzor teljes mértékben jól működik. Ezt követően könnyebb lesz egy nyílt forráskódú vagy egy saját 6502 illesztése a NES-embe mivel biztos lehetek, hogy az általam készített hardver helyesen, az eredeti NES-nek megfelelően működik (így könnyebb a CPU hibáinak megtalálása). 

\section{NES kontrollerek kezelése}

Az eredeti NES kontrollerek működését \aref{sec:NES-controller}. fejezet során már ismertettem. Az FPGA implementáció során a modul feladata a kontrollerek párhuzamos-soros léptetőregiszterei felé a vezérlőjelek küldése, tehát az olvasási szándék jelzése ($controller\_out\_latch$), illetve a bitek olvasását követő órajelek küldése ($controller_1-_2\_out\_clk$). A kontrollerekből érkező adatok mintavételezésére egy felfutó él érzékelést készítettem a CPU \$4016-as (kontroller 1) és \$4017-as (kontroller 2) regiszterek olvasásának detektálására annak érdekében, hogy mindig stabil adatokat olvassunk (az olvasás egyszer történjen meg). Az élérzékelést egy-egy kétbites léptetőregiszterrel implementáltam, amelyekbe egyes értéket léptetek a jelek érzékelésekor.   

%phi
A kontrollerekből érkező egybites adatokat, a CPU egy bájtként olvassa ki (az adat a 1. helyi értékű %nem 1-es helyi érték? 0-s nincsen
biten szerepel). A CPU adatbusz kezelése során itt is figyeltem az interfész helyes implementációjára, tehát a $\phi_2\_falling$ jel hatására nullás értékre állítom a CPU adat kimeneteket. A modulban mind a két kontroller írását és olvasását elhelyeztem.
